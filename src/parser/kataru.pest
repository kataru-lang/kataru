// Kataru Parsing Expression Grammar.

// Top level file
File          = _{ SOI ~ BLANK_LINE* ~ FileHeader ~ BLANK_LINE* ~ FilePassages ~ BLANK_LINE* ~ EOI }
FileHeader    = _{ StartDocument ~ (BLANK_LINE* ~ Headers)? }
FilePassages  = _{ StartDocument ~ (BLANK_LINE* ~ Passages)? }
StartDocument =  { "---" | "===" }

// Headers
Headers = _{ BLANK_LINE* ~ Header ~ (NEWLINE ~ BLANK_LINE* ~ Header)* }
Header  = _{ NamespaceHeader | StateHeader | CharactersHeader | CommandsHeader | OnExitHeader | OnEnterHeader }

// Expansions
PassageExpansion   =  { "$passage" }
CharacterExpansion =  { "$character" }
Expansion          = _{ (PassageExpansion | CharacterExpansion) ~ "." }

// State and variables
state               =  { "state" }
StateHeader         = _{ state ~ ":" ~ (BLANK_LINE+ ~ VariableDefinitions)? }
VariableDeclaration = _{ Expansion? ~ Identifier }
VariableDefinition  =  { VariableDeclaration ~ ":" ~ SPACE ~ Expression }
VariableDefinitions = _{ START_INDENTATION ~ VariableDefinition ~ (PEEK_INDENTATION ~ VariableDefinition)* ~ DROP }

// Namespace
namespace       =  { "namespace" }
NamespaceHeader = _{ (namespace ~ ":" ~ SPACE ~ NamespaceId) }
NamespaceId     = _{ global | Identifier }
Namespace       = @{ Identifier }
global          =  { "global" }

// Characters
characters           =  { "characters" }
CharacterName        = @{ Identifier }
CharactersHeader     = _{ characters ~ ":" ~ (NEWLINE ~ CharacterDefinitions)? }
CharacterDefinition  =  { CharacterName ~ ":" ~ (NEWLINE+ ~ CharacterDataEntries)? }
CharacterDefinitions = _{ START_INDENTATION ~ CharacterDefinition ~ (PEEK_INDENTATION ~ CharacterDefinition)* ~ DROP }
CharacterDataEntries = _{ START_INDENTATION ~ CharacterDataEntry ~ (PEEK_INDENTATION ~ CharacterDataEntry)* ~ DROP }
CharacterDataEntry   =  { Identifier ~ ":" ~ SPACE ~ Expression }

// Commands
commands           =  { "commands" }
CommandName        = @{ Identifier }
CommandsHeader     = _{ commands ~ ":" ~ (BLANK_LINE+ ~ CommandDefinitions)? }
CommandDeclaration = _{ Expansion? ~ CommandName }
CommandDefinitions = _{ START_INDENTATION ~ Command ~ (PEEK_INDENTATION ~ Command)* ~ DROP }
Command            =  { CommandDeclaration ~ ":" ~ CommandParams? }
CommandCall        =  { (Identifier ~ ".")? ~ CommandName ~ ":" ~ CommandParams }

// Command params
CommandParam       =  { Identifier ~ ":" ~ SPACE ~ Expression }
CommandParams      = _{ (SPACE+ ~ CommandParamsBrace) | (BLANK_LINE+ ~ CommandParamsFlow) }
CommandParamsFlow  = _{ START_INDENTATION ~ CommandParam ~ (PEEK_INDENTATION ~ CommandParam)* ~ DROP }
CommandParamsBrace = _{ "{" ~ SPACE_OR_LINE* ~ CommandParamsCsv ~ SPACE_OR_LINE* ~ "}" }
CommandParamsCsv   = _{ CommandParam ~ ("," ~ SPACE_OR_LINE* ~ CommandParam)* }

// Command positional
CommandPositionalCall      =  { (Identifier ~ ".")? ~ CommandName ~ ":" ~ SPACE_OR_LINE+ ~ CommandPositionalParams }
CommandPositionalParams    = _{ "[" ~ SPACE_OR_LINE* ~ CommandPositionalParamsCsv ~ SPACE_OR_LINE* ~ "]" }
CommandPositionalParamsCsv = _{ Expression ~ ("," ~ SPACE_OR_LINE* ~ Expression)* }

// Enter/exit
onExit        = { "onExit" }
OnExitHeader  = { onExit ~ ":" ~ BLANK_LINE+ ~ START_INDENTATION ~ Set ~ DROP }
onEnter       = { "onEnter" }
OnEnterHeader = { onEnter ~ ":" ~ BLANK_LINE+ ~ START_INDENTATION ~ Set ~ DROP }

// Format strings
FormatExpression      = _{ "{" ~ Expression ~ "}" }
FormatExpressionOrVar = _{ FormatExpression | Variable }
StringLiteral         =  { (!(NEWLINE | FormatExpressionOrVar) ~ ANY)+ }
StringWithVariable    = _{ StringLiteral ~ (FormatExpressionOrVar ~ StringLiteral?)* }

// Passages
Passages          = _{ (Passage ~ BLANK_LINE*)* }
PassageName       = @{ Identifier }
PassageReference  =  { (Namespace ~ ":")* ~ PassageName }
Passage           = _{ PassageName ~ ":" ~ (BLANK_LINE+ ~ Lines)? }
Dialogue          =  { CharacterName ~ ":" ~ SPACE ~ StringWithVariable }
DialogueContinued =  { StringWithVariable }

// Choices
choices         =  { "choices" }
Choices         =  { choices ~ ":" ~ ChoiceMap }
ChoiceMap       = _{ (SPACE_OR_LINE+ ~ ChoiceMapBrace) | (BLANK_LINE+ ~ ChoiceMapFlow) }
ChoiceMapBrace  = _{ "{" ~ SPACE_OR_LINE* ~ ChoiceMapCsv ~ SPACE_OR_LINE* ~ "}" }
ChoiceMapCsv    = _{ Choice ~ ("," ~ SPACE_OR_LINE* ~ Choice)* }
ChoiceMapFlow   = _{ START_INDENTATION ~ Choice ~ (PEEK_INDENTATION ~ Choice)* ~ DROP }
Choice          =  { (ChoiceCondition | ChoiceExplicit | ChoiceLines) }
ChoiceExplicit  = _{ ChoiceString ~ ":" ~ (SPACE+ ~ PassageReference) }
ChoiceLines     = _{ ChoiceString ~ ":" ~ (BLANK_LINE+ ~ Lines)? }
ChoiceCondition = _{ IfExpression ~ ":" ~ ChoiceMap }
ChoiceKey       = _{ IfExpression | ChoiceString }
ChoiceString    = @{ UnquotedStringKey | QuotedString }

// Conditionals
if              = { "if" }
else            = { "else" }
IfExpression    = { if ~ SPACE ~ Expression }
IfStatement     = { IfExpression ~ ":" ~ (BLANK_LINE+ ~ Lines)? }
ElseIfStatement = { START_INDENTATION ~ else ~ SPACE ~ IfExpression ~ ":" ~ (BLANK_LINE+ ~ Lines)? ~ DROP }
ElseStatement   = { START_INDENTATION ~ else ~ ":" ~ (BLANK_LINE+ ~ Lines)? ~ DROP }
Conditional     = { IfStatement ~ (BLANK_LINE+ ~ ElseIfStatement)* ~ (BLANK_LINE+ ~ ElseStatement)? }

// Set
set          =  { "set" }
Set          =  { set ~ ":" ~ Setters }
SetOperator  =  { SPACE ~ (Add | Sub) }
Setter       = _{ (VariableDeclaration | Variable) ~ SetOperator? ~ ":" ~ SPACE ~ Expression }
Setters      = _{ (SPACE+ ~ SettersBrace) | (BLANK_LINE+ ~ SettersFlow) }
SettersFlow  = _{ START_INDENTATION ~ Setter ~ (PEEK_INDENTATION ~ Setter)* ~ DROP }
SettersBrace = _{ "{" ~ SPACE_OR_LINE* ~ SetterCsv ~ SPACE_OR_LINE* ~ "}" }
SetterCsv    = _{ Setter ~ ("," ~ SPACE_OR_LINE* ~ Setter)* }

// Input
input          = { "input" }
Input          = { input ~ ":" ~ InputVariant }
InputVariant   = { (SPACE+ ~ InputBrace) | (BLANK_LINE+ ~ InputFlow) }
InputFlow      = { START_INDENTATION ~ InputStatement ~ DROP }
InputBrace     = { "{" ~ SPACE_OR_LINE* ~ InputStatement ~ SPACE_OR_LINE* ~ "}" }
InputStatement = { (VariableDeclaration | Variable) ~ ":" ~ SPACE ~ StringWithVariable }

// Call/Return
call   = { "call" }
Call   = { call ~ ":" ~ SPACE ~ PassageReference }
return = { "return" }
Return = { return ~ ":" }

// Lines
Line     = _{
    (Call | Return | Choices | Conditional | Set | Input | CommandPositionalCall | CommandCall | Dialogue | DialogueContinued)
}
LineFlow = _{ "-" ~ (SPACE ~ Line)? }
Lines    = _{ START_INDENTATION ~ LineFlow ~ (PEEK_INDENTATION ~ LineFlow)* ~ DROP }

// Expressions
// An expression is a sequence of operands connected by unary or binary operators.
// The AST will only have expression groups for expressions that must be evaluated.
// Values and Variables are exposed directly.
// Binary operators can be chained, thus binary expressions can be arbitrarily long.
UnaryExpression  =  { UnaryOperator ~ UnaryOperand }
BinaryExpression =  { (BinaryOperand ~ BinaryOperator)+ ~ BinaryOperand }
Expression       = _{ BinaryExpression | UnaryExpression | UnaryOperand }
UnaryOperand     = _{ Atom | "(" ~ Expression ~ ")" }
BinaryOperand    = _{ UnaryExpression | UnaryOperand }

// Operators
UnaryOperator  = _{ SPACE? ~ (Not | Add | Sub) ~ SPACE? }
BinaryOperator = _{ SPACE? ~ (Add | Sub | Mul | Div | And | Or | Eq | Neq | Leq | Lt | Geq | Gt) ~ SPACE? }
Not            =  { "not" }
Add            =  { "+" }
Sub            =  { "-" }
Mul            =  { "*" }
Div            =  { "/" }
And            =  { "and" }
Or             =  { "or" }
Eq             =  { "==" }
Neq            =  { "!=" }
Leq            =  { "<=" }
Lt             =  { "<" }
Geq            =  { ">=" }
Gt             =  { ">" }

// Strings
UnsafeStringChar    = _{ "\"" | "(" | ")" | NEWLINE }
NonQuoteSPACEChar   = _{ !(UnsafeStringChar | SPACE) ~ ANY }
NonQuoteNewlineChar = _{ !UnsafeStringChar ~ ANY }
UnquotedString      =  { !UnaryOperator ~ NonQuoteSPACEChar+ }
String              = @{ NonQuoteNewlineChar* }
QuotedString        =  { "\"" ~ String ~ "\"" }
UnquotedStringKey   =  { (!(NEWLINE | (":" ~ SPACE_OR_LINE)) ~ ANY)+ }

// Values
Number = @{ (Add | Sub)? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
Bool   = @{ "true" | "false" }
Value  = _{ Number | Bool | QuotedString | UnquotedString }
Atom   = _{ QuotedString | Variable | Value }

// Common
Identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | ".")* }
Variable   = @{ "$" ~ Identifier }

// Whitespace and comments
// Sematnic indentation should be handled with the following pattern:
// START_INDENTATION ~ X ~ (PEEK_INDENTATION ~ X)* ~ DROP
SPACE             = _{ " " | "\t" }
BLANK_LINE        = _{ SPACE* ~ NEWLINE }
SPACE_OR_LINE     = _{ SPACE | NEWLINE }
INDENTATION       = _{ SPACE+ }
PEEK_INDENTATION  = _{ NEWLINE ~ (BLANK_LINE)* ~ PEEK_ALL }
START_INDENTATION = _{ PEEK_ALL ~ PUSH(INDENTATION) }
COMMENT           =  { SPACE* ~ "#" ~ (!NEWLINE ~ ANY)* }
