// Builtins
COMMENT = { WhiteSpace* ~ "#" ~ (!NEWLINE ~ ANY)* }

// Whitespace
WhiteSpace       = _{ " " | "\t" }
WhiteSpaceLine   = _{ WhiteSpace | NEWLINE }
SectionSeparator = _{ WhiteSpace* ~ NEWLINE ~ WhiteSpaceLine* }
Indentation      = _{ WhiteSpace+ }

// Common
Identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
Variable   = @{ "$" ~ Identifier }

// Top level file
File         = _{ SOI ~ WhiteSpaceLine* ~ FileHeader ~ SectionSeparator ~ FilePassages ~ WhiteSpaceLine* ~ EOI }
FileHeader   = _{ StartDocument ~ (SectionSeparator ~ Headers)? }
FilePassages = _{ StartDocument ~ (SectionSeparator ~ Passages)? }

Headers = _{ WhiteSpaceLine* ~ Header ~ (NEWLINE ~ WhiteSpaceLine* ~ Header)* }
Header  = _{ NamespaceHeader | StateHeader | CharactersHeader | CommandsHeader }

StartDocument = { "---" | "===" }

// Expansions
PassageExpansion   =  { "$passage" }
CharacterExpansion =  { "$character" }
Expansion          = _{ (PassageExpansion | CharacterExpansion) ~ "." }

// State and variables
state               =  { "state" }
StateHeader         = _{ state ~ ":" ~ (NEWLINE+ ~ VariableDefinitions)? }
VariableDeclaration = _{ Expansion? ~ Identifier }
VariableDefinition  =  { VariableDeclaration ~ ":" ~ WhiteSpace ~ Expression }
VariableDefinitions = _{ PUSH(Indentation) ~ VariableDefinition ~ (NEWLINE ~ PEEK_ALL ~ VariableDefinition)* ~ DROP }

// Namespace
namespace       =  { "namespace" }
NamespaceHeader = _{ (namespace ~ ":" ~ WhiteSpace ~ Namespace) }
Namespace       = _{ global | Identifier }
global          =  { "global" }

// Characters
characters           =  { "characters" }
CharactersHeader     = _{ characters ~ ":" ~ (NEWLINE ~ CharacterDefinitions)? }
CharacterDefinition  =  { Identifier ~ ":" ~ (NEWLINE+ ~ CharacterDataEntries)? }
CharacterDefinitions = _{ PUSH(Indentation) ~ CharacterDefinition ~ (NEWLINE ~ PEEK_ALL ~ CharacterDefinition)* ~ DROP }
CharacterDataEntries = _{ PUSH(Indentation) ~ CharacterDataEntry ~ (NEWLINE ~ PEEK_ALL ~ CharacterDataEntry)* ~ DROP }
CharacterDataEntry   =  { Identifier ~ ":" ~ WhiteSpace ~ Expression }

// Commands
commands           =  { "commands" }
CommandName        = @{ Identifier }
CommandsHeader     = _{ commands ~ ":" ~ (NEWLINE+ ~ CommandDefinitions)? }
CommandDeclaration = _{ Expansion? ~ CommandName }
CommandDefinitions = _{ PUSH(Indentation) ~ Command ~ (NEWLINE ~ PEEK_ALL ~ Command)* ~ DROP }

Command                    =  { CommandDeclaration ~ ":" ~ CommandParams? }
CommandCall                =  { (Identifier ~ ".")? ~ CommandName ~ ":" ~ CommandParams? }
CommandParam               =  { Identifier ~ ":" ~ WhiteSpace ~ Expression }
CommandParams              = _{ (WhiteSpace+ ~ CommandParamsBrace) | (NEWLINE+ ~ CommandParamsFlow) }
CommandParamsFlow          = _{ PUSH(Indentation) ~ CommandParam ~ (NEWLINE ~ PEEK_ALL ~ CharacterDataEntry)* ~ DROP }
CommandParamsBrace         = _{ "{" ~ WhiteSpaceLine* ~ CommandParamsCsv ~ WhiteSpaceLine* ~ "}" }
CommandParamsCsv           = _{ CommandParam ~ ("," ~ WhiteSpaceLine* ~ CommandParam)* }
CommandPositionalCall      =  { (Identifier ~ ".")? ~ Identifier ~ ":" ~ WhiteSpaceLine+ ~ CommandPositionalParams? }
CommandPositionalParams    = _{ "[" ~ WhiteSpaceLine* ~ CommandPositionalParamsCsv ~ WhiteSpaceLine* ~ "]" }
CommandPositionalParamsCsv = _{ Expression ~ ("," ~ WhiteSpaceLine* ~ Expression)* }

Passages              = _{ Passage* }
Passage               =  { Identifier ~ ":" ~ (NEWLINE+ ~ Lines)? }
LineDialogue          =  { Identifier ~ ":" ~ WhiteSpace ~ StringWithVariable }
LineContinued         =  { (!Variable ~ ANY) ~ Variable ~ ANY }
LineVariant           = _{ (LineDialogue | LineContinued | CommandCall | CommandPositionalCall) }
Line                  = _{ "-" ~ (WhiteSpace ~ LineVariant)? }
FormatExpression      =  { "{" ~ Expression ~ "}" }
FormatExpressionOrVar = _{ FormatExpression | Variable }
StringLiteral         =  { (!(NEWLINE | FormatExpressionOrVar) ~ ANY)+ }
StringWithVariable    = _{ StringLiteral ~ (FormatExpressionOrVar ~ StringLiteral?)* }
Lines                 = _{ PUSH(Indentation) ~ Line ~ (NEWLINE ~ PEEK_ALL ~ Line)* ~ DROP }

// Expressions
// An expression is a sequence of operands connected by unary or binary operators.
// The AST will only have expression groups for expressions that must be evaluated.
// Values and Variables are exposed directly.
// Binary operators can be chained, thus binary expressions can be arbitrarily long.
UnaryExpression  =  { UnaryOperator ~ UnaryOperand }
BinaryExpression =  { (BinaryOperand ~ BinaryOperator)+ ~ BinaryOperand }
Expression       = _{ BinaryExpression | UnaryExpression | UnaryOperand }
UnaryOperand     = _{ Atom | "(" ~ Expression ~ ")" }
BinaryOperand    = _{ UnaryExpression | UnaryOperand }

// Operators
UnaryOperator  = _{ WhiteSpace? ~ (Not | Add | Sub) ~ WhiteSpace? }
BinaryOperator = _{ WhiteSpace? ~ (Add | Sub | Mul | Div | And | Or | Eq | Neq | Leq | Lt | Geq | Gt) ~ WhiteSpace? }
Not            =  { "not" }
Add            =  { "+" }
Sub            =  { "-" }
Mul            =  { "*" }
Div            =  { "/" }
And            =  { "and" }
Or             =  { "or" }
Eq             =  { "==" }
Neq            =  { "!=" }
Leq            =  { "<=" }
Lt             =  { "<" }
Geq            =  { ">=" }
Gt             =  { ">" }

// Strings
UnsafeStringChar       = _{ "\"" | "(" | ")" | NEWLINE }
NonQuoteWhitespaceChar = _{ !(UnsafeStringChar | WhiteSpace) ~ ANY }
NonQuoteNewlineChar    = _{ !UnsafeStringChar ~ ANY }
UnquotedString         =  { !UnaryOperator ~ NonQuoteWhitespaceChar+ }
String                 = @{ NonQuoteNewlineChar* }
QuotedString           =  { "\"" ~ String ~ "\"" }

// Values
Number = @{ (Add | Sub)? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
Bool   = @{ "true" | "false" }
Value  = _{ Number | Bool | QuotedString | UnquotedString }
Atom   = _{ QuotedString | Variable | Value }
